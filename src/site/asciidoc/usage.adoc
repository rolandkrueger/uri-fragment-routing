= User Manual
Roland Kr√ºger <mail AT rolandkrueger dot info>
v1.0, 2017-01-12
:source-highlighter: coderay
:toc:

This document describes how the library `uri-fragment-routing` is used.

== Central Classes and Terminology

Let's first get an overview of the most important classes and interfaces from the library which you should know. The following classes and interfaces play a central role in the framework:

* `UriActionMapperTree`: The main class of the framework which manages the complete set of known URI fragments
* `UriPathSegmentActionMapper`: Interface which defines an _action mapper_. These are classes which are responsible for handling exactly one particular path segment of any given URI fragment.
* `UriActionCommand`: Interface for defining _action command objects_. These commands will be executed as a result of the URI fragment interpretation process. Each URI fragment can be resolved to a `UriActionCommand` which will be executed when the corresponding URI fragment is interpreted.
* `UriParameter`: A URI fragment can contain an arbitrary number of parameter values. These parameters are represented by classes implementing the interface `UriParameter`.
* `ParameterValueConverter`: Each URI parameter has a specific type. Since parameters are represented in a URI fragment as a String, a conversion needs to take place between its type and its String representation. Classes implementing the `ParameterValueConverter` interface are responsible for this.
* `ParameterValue`: When a URI fragment has been interpreted by the framework, all parameter values contained in the URI fragment have been extracted and converted into their respective type. `ParameterValue` is a generic class which manages a converted parameter value in a type-safe way.
* `CapturedParameterValues`: The complete set of parameter values found in a URI fragment is managed by this class.

We will take a closer look at these classes and interfaces in the following sub-sections to get a better understanding of what they can do for us.

=== UriActionMapperTree

All URI fragments that an application can handle have to be defined with an object of class `UriActionMapperTree`. This class is then responsible for two main tasks

. Interpreting a URI fragment visited by the user. The mapper tree tries to resolve any given URI fragment to a `UriActionCommand`. If such a command object could be resolved for a URI fragment, it is executed by the mapper tree.
. Assembling a valid URI fragment which can be resolved to a particular action command. A set of parameter values can be provided to be added to the assembled fragment.

The `UriActionMapperTree` is thread-safe. This means that only one instance of a mapper tree needs to be instantiated per application. You should try to avoid creating a mapper tree for every user session.

Creating and configuring a mapper tree can be done in two ways. You can either assemble all necessary parts by hand or you can use a builder class provided by class `UriActionMapperTree`. The latter option is recommended, since the builder infrastructure leads you through the process of assembling the hierarchical structure of a mapper tree with a fluent API which only allows to use those operations which make sense in the current context.

Both variants will be described in detail in the remainder of this manual.

=== UriPathSegmentActionMapper

When a URI fragment is interpreted, it is first disassembled into a set of distinct tokens. For example, the following URI fragment

    #!/admin/users/id/4711/profile/activeTabsheet/address

is disassembled into the following list of tokens:

    ["admin", "users", "id", "4711", "profile", "activeTabsheet", "address"]

This list is then interpreted by the mapper tree. Parts of this list are parameter values (here ["id", "4711"] and ["activeTabsheet", "address]). The other parts make up the directory-like hierarchical URI fragment structure (here ["admin", "users", "profile"]). For each of the directory parts (_path segments_), there is one instance of a `UriPathSegmentActionMapper` which is responsible of handling this part. These _action mappers_ have different tasks. The task of the inner segments is to pass the interpretation process on to the action mapper of the next hierarchy level. For instance, the action mapper responsible for the `admin` path segment is responsible to pass the interpretation process on to the action mapper for the `users` path segment.

The second task of these action mappers is to provide a `UriActionCommand` class if there is no further sub-mapper available to which the interpretation process could be passed. In the example, the action mapper responsible for the `profile` path segment would return the action command which displays the profile view in the user administration area.

There are two basic implementations available for the `UriPathSegmentActionMapper` interface:

* A `DispatchingUriPathSegmentActionMapper` is an action mapper which is responsible for the inner path segments which may need to pass the interpretation process on to the next level. In the example, the action mappers for `admin` and `users` would be implemented with this class.
* A `SimpleUriPathSegmentActionMapper` is responsible for the leaf path segments which do not have any sub-mappers. In the example, the `profile` path segment would be handled by this mapper type. The only task of `SimpleUriPathSegmentActionMapper`s is to provide a fully configured URI action command class.

=== UriActionCommand

You can assign different parts of the URI fragment hierarchy a class which implements the `org.roklib.urifragmentrouting.UriActionCommand` interface. This interface is derived from `java.lang.Runnable` and thus implements the _Command Design Pattern_. When a URI fragment is resolved to a URI action command class, this class is instantiated and executed.

Each action command needs some context before it can be executed. For example, it needs to know the URI parameter values which have been extracted from the URI fragment. This context data will be injected into the action command object by the mapper tree on demand. For this, you can add setter methods to your action command classes which are annotated with one of the following annotations: `AllCapturedParameters`, `CapturedParameter`, `CurrentUriFragment`, and `RoutingContext`.

We will learn about these annotations and how to implement URI action commands later in this manual.

=== URI parameters and parameter value converters

When you want to add parameter values to your URI fragments, you need to define a parameter object for every parameter you want to use. URI parameters are represented by classes implementing the `org.roklib.urifragmentrouting.parameter.UriParameter` interface. Parameter objects define the parameter's data type (e. g. Integer, Date, or Double) and the parameter's id. The id will be used to identify the parameter in the URI fragment. You will then only work with these type-safe parameter objects so that you don't have to hassle with String values which need to be converted into the correct data type before they can be used. The data conversion between a parameter's String representation and its typed value is taken care of by parameter value converters. Such a converter implements the interface `org.roklib.urifragmentrouting.parameter.converter.ParameterValueConverter`. The framework provides parameter and converter implementations for the standard data types. Of course you can define your own set of parameters and converters for other data types.

==== Single-Valued and Multi-Valued Parameters

A URI parameter can be single-valued or multi-valued. Typical examples for single-valued parameters are entity ids, user names or boolean flags. A multi-valued parameter is represented by a single instance of a `UriParameter` but consists of more than one parameter value. An example for such a type of parameters is a geographic coordinate which consists of a longitude and a latitude. With class `org.roklib.urifragmentrouting.parameter.Point2DUriParameter`, the framework provides such a parameter out of the box.

=== Parameter Values

When a parameterized URI fragment has been interpreted, all parameter values extracted from that URI fragment need to be transported to the `UriActionCommand` which is executed as a result of the interpretation process. In addition to the typed parameter value, some more information needs to be transmitted with the parameter value. If a required parameter value could not successfully be extracted from the URI fragment, information about the concrete error needs to be preserved. If a URI parameter value is not present in the URI fragment but the parameter object defines a default value, this default value will be transmitted instead. This value then needs to be marked as such.

In order to be able to aggregate this information, a specific class `org.roklib.urifragmentrouting.parameter.value.ParameterValue<V>` is used. This is a generic class whose generic type is set to the data type of the parameter. In addition to the converted parameter value extracted from the URI fragment, it also contains information about whether or not the parameter extraction was successful. This class also indicates with a boolean flag if the contained value is the parameter's default value.

=== Parameter Modes

The framework supports three different types of parameter representations:

* Directory mode with names
* Directory mode without names
* Query parameter mode

Using the enumeration `org.roklib.urifragmentrouting.parameter.ParameterMode` you can specify in what mode the URI action mapper tree shall operate.

Let's describe these modes.

==== Directory Mode With Names

In this mode, parameter values are contained in a URI fragment in a directory-like format. Their parameter ids are also contained in the URI fragment. Example:

    #!/admin/users/id/4711/showHistory/startDate/2017-01-01/endDate/2017-01-31

This URI fragment contains three parameters: `id`, `startDate` and `endDate`. As you can see, the parameters' ids are contained in the the URI fragment together with their concrete values.

==== Directory Mode Without Names

This mode operates similar to the previous one, with the difference that the parameters' ids are not contained in the URI fragment. In the mode, the example above looks like follows:

    #!/admin/users/4711/showHistory/2017-01-01/2017-01-31

When this mode is used, parameters must not be defined as optional. Otherwise, a missing parameter value could not be distinguished from the consecutive URI fragment tokens.

==== Query Mode

In this mode, all URI parameters are appended to the URI fragment in the same way as customary URI query parameters are appended to a URI (as described in https://tools.ietf.org/html/rfc3986#section-3.4[RFC 3986]). The above example will look like follows with this mode:

    #!/admin/users/showHistory?id=4711&startDate=2017-01-01&endDate=2017-01-31

== A First Simple Scenario

Now that we have learned about the basic classes and concepts of this library, we'll put our knowledge to use and start building URI action mapper trees. We will start small and begin with the simplest possible mapper tree.

In this section, we will build a mapper tree which is able to handle the following URI fragment:

    #!/helloWorld
	
When the user visits this fragment, we want to print `Hello World!` to the console. To do this, we need two things: we have to define an action class and the URI action mapper tree which can resolves this URI fragment to this action class.

Let's first define the action class:

[source,java]
----
public static class HelloWorldActionCommand implements UriActionCommand {
    @Override
    public void run() {
        System.out.println("Hello World!);
    }
}
----

Now we can build the URI action mapper tree.

[source,java]
----
UriActionMapperTree mapperTree =
    UriActionMapperTree.create().buildMapperTree()
        .map("helloWorld").onAction(HelloWorldActionCommand.class)
        .finishMapper().build();
----

To do so, we use the builder provided to us by `UriActionMapperTree.create()`. This builder will guide us through the complete process of creating and configuring the full URI action mapper tree. We start the building process with `buildMapperTree()`. A mapper tree is built in a depth-first manner. That is, we start with the first level of the directory-like URI fragment structure (`\#!/firstLevel`) and continue building the sub-levels from there (`#!/firstLevel/secondLevel`). We will learn how to do that in the following sections.

In our simple example, we only want to map a single path segment on an action class. We do this with the `map()` method. This method will create a `SimpleUriPathSegmentActionMapper` for us. We set the action command object for this mapper with the `onAction()` method. When we're done configuring the current action mapper, we finalize it with `finishMapper()`. After this method has been called for the current action mapper, we cannot add any further sub-mappers to it. However, this would not be possible in our example anyway, since we created a simple action mapper which does not support sub-mappers. Simple action mappers represent the leaves of the mapper tree.

When we're done composing the URI action mapper tree, we finalize the tree with the `build()` method. This will return the fully configured `UriActionMapperTree` ready for action.

How can we now interpret URI fragments visited by the user with this mapper tree?

This is done with the `interpretFragment()` method. We can pass a String holding the current URI fragment to this method:

[source,java]
----
UriActionCommand command = mapperTree.interpretFragment("/helloWorld");
----

This will trigger the interpretation process during which the URI fragment is disassembled and resolved to a URI action command class. The action mapper tree will resolve this fragment to the class object provided by us during the construction of the mapper tree: `HelloWorldActionCommand`. It will then create an instance of this class, execute it and return the command object as a result.

If the given URI fragment could not be resolved (e. g. if we made a typo and passed `/heloWrold` to the interpretation method), `null` is returned and no action command object is executed.

With this, we have successfully created a very simple but fully functional URI action mapper tree which is able to handle one particular URI fragment.

== Defining a Default Action Command

As we have seen in the previous section, if a URI fragment could not successfully be interpreted, `null` is returned from the interpretation process as a result. We can prevent this by defining a default action command which will be executed each time a URI fragment could not be successfully resolved. We can this on the instance of the URI action mapper tree:

[source,java]
----
mapperTree.setDefaultActionCommandClass(MyDefaultActionCommand.class);
----

or alternatively while building this tree with the builder objects:

[source,java]
----
mapperTree = UriActionMapperTree.create()
             .useDefaultActionCommand(MyDefaultActionCommand.class)
             .buildMapperTree()
             ...
----

== Adding Some More Top-Level Mappers

Now we have a good starting point from which we can go on. We will expand our mapper tree with more mappers in the next step. Let us define the following three top-level path segments which can be handled by the mapper tree:

....
#!/user
#!/admin
#!/settings
....

We can do this in the same way as we did above, except that we continue building the mapper tree after we have fully configured the first action mapper:

[source,java]
----
mapperTree = UriActionMapperTree.create().buildMapperTree()
             .map("user").onAction(GoToUserAreaActionCommand.class).finishMapper()
             .map("admin").onAction(GoToAdminAreaActionCommand.class).finishMapper()
             .map("settings").onAction(GoToSettingsActionCommand.class).finishMapper()
             .build();
----

As you can see, after we called `finishMapper()` the builder is reset to the root of the mapper tree and we can go on adding the next sibling path segment to be handled by the mapper tree.

== Adding Hierarchy

Next we want to add some hierarchy to the mapper tree. We would now like to be able to interpret the following URI fragments:

....
#!/user
#!/user/profile
#!/admin
#!/admin/users
#!/admin/groups
#!/settings
....

We will do this in a depth-first manner:

[source,java]
----
UriActionMapperTree mapperTree = UriActionMapperTree.create().buildMapperTree()
            .mapSubtree("user").onAction(GoToUserAreaActionCommand.class)
                .onSubtree()
                .map("profile").onAction(GoToUserProfileActionCommand.class).finishMapper()
            .finishMapper()
            .mapSubtree("admin").onAction(GoToAdminAreaActionCommand.class)
                .onSubtree()
                .map("users").onAction(GoToUserAdministrationActionCommand.class).finishMapper()
                .map("groups").onAction(GoToGroupAdministrationActionCommand.class).finishMapper()
            .finishMapper()
            .map("settings").onAction(GoToSettingsActionCommand.class).finishMapper()
        .build();
----

The `user` and `admin` path segments now need to have their type changed from a simple action mapper into a dispatching action mapper which allows adding sub-mappers. This is reflected by the builder methods we have to use now: `mapSubtree()` initiates the construction of a sub-mapper hierarchy. We can still assign an action command class to this mapper. This will be executed when the dispatching action mapper is directly accessed with the URI fragment `#!/user`.

After the dispatching mapper has been fully configured, we can go to the next hierarchy level and configure the dispatching mapper's sub-mappers. We initiate the construction of this sub-tree with method `onSubtree()`. From this point on, we can continue with constructing the mapper tree on the next level as we did on the root level. As we can see, we are here dealing with a recursive structure. We can now use the same builders as we did on the root level. We can thus nest the action mappers as deeply as we like.

In our example we only add simple action mappers on the second level of the action mapper tree. We could, however, choose to add a second level of dispatching action mappers and a third level of simple mappers and so on by repeatedly calling `mapSubtree()`.

It is important to note that method `finishMapper()` will leave the current level of nesting and move the "builder's cursor" up to the parent level. This is why we have to call `finishMapper()` twice after we configured the action mapper for `profile`. The first call to `finishMapper()` moves the cursor up to the level of `user` while the second call to `finishMapper()` moves it back to the root level.

== Reusing Path Segment Names

Until now, we defined action mappers for a unique set of path segment names. The following path segment names are currently in use by our action mapper tree: `user`, `profile`, `admin`, `users`, `groups`, and `settings`.

What happens, when we reuse one of the path segment names? Let's add a `profile` sub-mapper for the `admin` dispatching mapper:

[source,java]
----
UriActionMapperTree mapperTree = UriActionMapperTree.create().buildMapperTree()
            .mapSubtree("user").onAction(GoToUserAreaActionCommand.class)
                .onSubtree()
                .map("profile").onAction(GoToUserProfileActionCommand.class).finishMapper()
            .finishMapper()
            .mapSubtree("admin").onAction(GoToAdminAreaActionCommand.class)
                .onSubtree()
                .map("profile").onAction(GoToUserAdministrationActionCommand.class).finishMapper()
            ... // remainder omitted for brevity
----

This gives us the following URI fragment structure:

....
#!/user
#!/user/profile
#!/admin
#!/admin/profile
#!/admin/users
#!/admin/groups
#!/settings
....

When we try to build this mapper tree, the following exception will be thrown:

    java.lang.IllegalArgumentException: Mapper name 'profile' is already in use

What does that mean? While this URI fragment structure is perfectly valid, we are not allowed to construct it in the way shown. We must not reuse the mapper name which is defined with the methods `map()` and `mapSubtree()`. This mapper name serves as a unique identifier of a URI action mapper object. Therefore, a mapper name must only be used once per action mapper tree.

What we need to do in this case is to separately define the mapper name for the action mapper and the path segment for which it is responsible. The methods `map()` and `mapSubtree()` we used until now conveniently set these two values to the same String, which is the one we passed as a parameter to these methods. We now have to do without this convenient feature and define both the mapper name and the path segment name separately:

[source,java]
----
UriActionMapperTree mapperTree = UriActionMapperTree.create().buildMapperTree()
            .mapSubtree("user").onAction(GoToUserAreaActionCommand.class)
                .onSubtree()
                .map("profile").onAction(GoToUserProfileActionCommand.class).finishMapper()
            .finishMapper()
            .mapSubtree("admin").onAction(GoToAdminAreaActionCommand.class)
                .onSubtree()
            .map("adminProfile").onPathSegment("profile").onAction(MyActionCommand.class).finishMapper()
            ... // remainder omitted for brevity
----

Now we define with the `map()` method the mapper name (the mapper's id) and set the path segment name for which the mapper is responsible in the next step with `onPathSegment()`. When we create a dispatching mapper with `mapSubtree()` we can define the path segment name with the overloaded variant of `mapSubtree()`:

[source,java]
----
mapSubtree("adminArea", "admin").onAction(GoToAdminAreaActionCommand.class)
----

Here we define the mapper name `adminArea` and the path segment name `admin`.

== Adding Parameters

== Writing URI Action Commands

== Generating Parameterized URI Fragments for Links

// TODO: explain URL encoding and decoding

== Configuring the URI Action Mapper Tree

== Providing Custom Parameter Types

== Advanced Action Mapper Types

== Assembling a URI Action Mapper Tree by Hand

== Logging a URI Action Mapper Tree

== Evaluating the Logging Output