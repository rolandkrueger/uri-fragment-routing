= User Manual
Roland Kr√ºger <mail AT rolandkrueger dot info>
v1.0, 2017-01-12
:toc:

This document describes how the library `uri-fragment-routing` is used.

== Central Classes and Terminology

Let's first get an overview of the most important classes and interfaces from the library which you should know. The following classes and interfaces play a central role in the framework:

* `UriActionMapperTree`: The main class of the framework which manages the complete set of known URI fragments
* `UriPathSegmentActionMapper`: Interface which defines an _action mapper_. These are classes which are responsible for handling exactly one particular path segment of any given URI fragment.
* `UriActionCommand`: Interface for defining _action command objects_. These commands will be executed as a result of the URI fragment interpretation process. Each URI fragment can be resolved to a `UriActionCommand` which will be executed when the corresponding URI fragment is interpreted.
* `UriParameter`: A URI fragment can contain an arbitrary number of parameter values. These parameters are represented by classes implementing the interface `UriParameter`.
* `ParameterValueConverter`: Each URI parameter has a specific type. Since parameters are represented in a URI fragment as a String, a conversion needs to take place between its type and its String representation. Classes implementing the `ParameterValueConverter` interface are responsible for this.
* `ParameterValue`: When a URI fragment has been interpreted by the framework, all parameter values contained in the URI fragment have been extracted and converted into their respective type. `ParameterValue` is a generic class which manages a converted parameter value in a type-safe way.
* `CapturedParameterValues`: The complete set of parameter values found in a URI fragment is managed by this class.

We will take a closer look at these classes and interfaces in the following sub-sections to get a better understanding of what they can do for us.

=== UriActionMapperTree

All URI fragments that an application can handle have to be defined with an object of class `UriActionMapperTree`. This class is then responsible for two main tasks

. Interpreting a URI fragment visited by the user. The mapper tree tries to resolve any given URI fragment to a `UriActionCommand`. If such a command object could be resolved for a URI fragment, it is executed by the mapper tree.
. Assembling a valid URI fragment which can be resolved to a particular action command. A set of parameter values can be provided to be added to the assembled fragment.

The `UriActionMapperTree` is thread-safe. This means that only one instance of a mapper tree needs to be instantiated per application. You should try to avoid creating a mapper tree for every user session.

Creating and configuring a mapper tree can be done in two ways. You can either assemble all necessary parts by hand or you can use a builder class provided by class `UriActionMapperTree`. The latter option is recommended, since the builder infrastructure leads you through the process of assembling the hierarchical structure of a mapper tree with a fluent API which only allows to use those operations which make sense in the current context.

Both variants will be described in detail in the remainder of this manual.

=== UriPathSegmentActionMapper

When a URI fragment is interpreted, it is first disassembled into a set of distinct tokens. For example, the following URI fragment

    #!/admin/users/id/4711/profile/activeTabsheet/address

is disassembled into the following list of tokens:

    ["admin", "users", "id", "4711", "profile", "activeTabsheet", "address]

This list is then interpreted by the mapper tree. Parts of this list are parameter values (here ["id", "4711"] and ["activeTabsheet", "address]). The other parts make up the directory-like hierarchical URI fragment structure (here ["admin", "users", "profile"]). For each of the directory parts (_path segments_), there is one instance of a `UriPathSegmentActionMapper` which is responsible of handling this part. These _action mappers_ have different tasks. The task of the inner segments is to pass the interpretation process on to the action mapper of the next hierarchy level. For instance, the action mapper responsible for the `admin` path segment is responsible to pass the interpretation process on to the action mapper for the `users` path segment.

The second task of these action mappers is to provide a `UriActionCommand` class if there is no further sub-mapper available to which the interpretation process could be passed. In the example, the action mapper responsible for the `profile` path segment would return the action command which displays the profile view in the user administration area.

There are two basic implementations available for the `UriPathSegmentActionMapper` interface:

* A `DispatchingUriPathSegmentActionMapper` is an action mapper which is responsible for the inner path segments which may need to pass the interpretation process on to the next level. In the example, the action mappers for `admin` and `users` would be implemented with this class.
* A `SimpleUriPathSegmentActionMapper` is responsible for the leaf path segments which do not have any sub-mappers. In the example, the `profile` path segment would be handled by this mapper type. The only task of `SimpleUriPathSegmentActionMapper`s is to provide a fully configured URI action command class.

=== UriActionCommand

You can assign different parts of the URI fragment hierarchy a class which implements the `org.roklib.urifragmentrouting.UriActionCommand` interface. This interface is derived from `java.lang.Runnable` and thus implements the _Command Design Pattern_. When a URI fragment is resolved to a URI action command class, this class is instantiated and executed.

Each action command needs some context before it can be executed. For example, it needs to know the URI parameter values which have been extracted from the URI fragment. This context data will be injected into the action command object by the mapper tree on demand. For this, you can add setter methods to your action command classes which are annotated with one of the following annotations: `AllCapturedParameters`, `CapturedParameter`, `CurrentUriFragment`, and `RoutingContext`.

We will learn about these annotations and how to implement URI action commands later in this manual.

=== URI parameters and parameter value converters

When you want to add parameter values to your URI fragments, you need to define a parameter object for every parameter you want to use. URI parameters are represented by classes implementing the `org.roklib.urifragmentrouting.parameter.UriParameter` interface. Parameter objects define the parameter's data type (e. g. Integer, Date, or Double) and the parameter's id. The id will be used to identify the parameter in the URI fragment. You will then only work with these type-safe parameter objects so that you don't have to hassle with String values which need to be converted into the correct data type before they can be used. The data conversion between a parameter's String representation and its typed value is taken care of by parameter value converters. Such a converter implements the interface `org.roklib.urifragmentrouting.parameter.converter.ParameterValueConverter`. The framework provides parameter and converter implementations for the standard data types. Of course you can define your own set of parameters and converters for other data types.

==== Single-Valued and Multi-Valued Parameters

A URI parameter can be single-valued or multi-valued. Typical examples for single-valued parameters are entity ids, user names or boolean flags. A multi-valued parameter is represented by a single instance of a `UriParameter` but consists of more than one parameter value. An example for such a type of parameters is a geographic coordinate which consists of a longitude and a latitude. With class `org.roklib.urifragmentrouting.parameter.Point2DUriParameter`, the framework provides such a parameter out of the box.

=== Parameter Values

When a parameterized URI fragment has been interpreted, all parameter values extracted from that URI fragment need to be transported to the `UriActionCommand` which is executed as a result of the interpretation process. In addition to the typed parameter value, some more information needs to be transmitted with the parameter value. If a required parameter value could not successfully be extracted from the URI fragment, information about the concrete error needs to be preserved. If a URI parameter value is not present in the URI fragment but the parameter object defines a default value, this default value will be transmitted instead. This value then needs to be marked as such.

In order to be able to aggregate this information, a specific class `org.roklib.urifragmentrouting.parameter.value.ParameterValue<V>` is used. This is a generic class whose generic type is set to the data type of the parameter. In addition to the converted parameter value extracted from the URI fragment, it also contains information about whether or not the parameter extraction was successful. This class also indicates with a boolean flag if the contained value is the parameter's default value.

=== Parameter Modes

The framework supports three different types of parameter representations:

* Directory mode with names
* Directory mode without names
* Query parameter mode

Using the enumeration `org.roklib.urifragmentrouting.parameter.ParameterMode` you can specify in what mode the URI action mapper tree shall operate.

Let's clarify these modes.

==== Directory Mode With Names

In this mode, parameter values are contained in a URI fragment in a directory-like format. Their parameter ids are also contained in the URI fragment. Example:

    /admin/users/id/4711/showHistory/startDate/2017-01-01/endDate/2017-01-31

This URI fragment contains three parameters: `id`, `startDate` and `endDate`. As you can see, the parameters' ids are contained in the the URI fragment together with their concrete values.

==== Directory Mode Without Names

This mode operates similar to the previous one, with the difference that the parameters' ids are not contained in the URI fragment. In the mode, the example above looks like follows:

    /admin/users/4711/showHistory/2017-01-01/2017-01-31

When this mode is used, parameters must not be defined as optional. Otherwise, a missing parameter value could not be distinguished from the consecutive URI fragment tokens.

==== Query Mode

In this mode, all URI parameters are appended to the URI fragment in the same way as customary URL query parameters. The above example will look like follows with this mode:

    /admin/users/showHistory?id=4711&startDate=2017-01-01&endDate=2017-01-31

== A First Simple Scenario

== Adding Some More Top-Level Mappers

== Adding Hierarchy

== Adding Parameters

== Writing URI Action Commands

== Generating Parameterized URI Fragments for Links

// TODO: explain URL encoding and decoding

== Configuring the URI Action Mapper Tree

== Providing Custom Parameter Types

== Advanced Action Mapper Types

== Assembling a URI Action Mapper Tree by Hand